% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/estimate_ct.R
\name{estimate_ct}
\alias{estimate_ct}
\title{Estimate smoothed ratio between observations and weighted past}
\usage{
estimate_ct(
  y,
  korder = 3L,
  dist_gamma = c(2.5, 2.5),
  x = 1:n,
  lambda = NULL,
  nsol = 100L,
  delay_distn = NULL,
  lambdamin = NULL,
  lambdamax = NULL,
  lambda_min_ratio = 1e-04,
  maxiter = 1e+05,
  init = configure_admm()
)
}
\arguments{
\item{y}{vector of the observations}

\item{korder}{Integer. Degree of the piecewise polynomial curve to be
estimated. For example, \code{korder = 0} corresponds to a piecewise constant
curve.}

\item{dist_gamma}{Vector of length 2. These are the shape and scale for the
assumed delay distribution.}

\item{x}{a vector of positions at which the observations have occurred. In an
ideal case, we would observe data at regular intervals (e.g. daily or
weekly) but this may not always be the case. May be numeric or Date.}

\item{lambda}{Vector. A user supplied sequence of tuning parameters which
determines the balance between data fidelity and
smoothness of the estimated ratio; larger \code{lambda} results in a smoother
estimate. The default, \code{NULL}
results in an automatic computation based on \code{nlambda}, the largest value
of \code{lambda} that would result in a maximally smooth estimate, and \code{lambda_min_ratio}.
Supplying a value of \code{lambda} overrides
this behaviour. It is likely better to supply a
decreasing sequence of \code{lambda} values than a single (small) value. If
supplied, the user-defined \code{lambda} sequence is automatically sorted in
decreasing order.}

\item{nsol}{Integer. The number of tuning parameters \code{lambda} at which to
compute Rt.}

\item{delay_distn}{in the case of a non-gamma delay distribution,
a vector of delay probabilities may be passed here. These will be coerced
to sum to 1, and padded with 0 in the right tail if necessary.}

\item{lambdamin}{Optional value for the smallest \code{lambda} to use. This should
be greater than zero.}

\item{lambdamax}{Optional value for the largest \code{lambda} to use.}

\item{lambda_min_ratio}{If neither \code{lambda} nor \code{lambdamin} is specified, the
program will generate a lambdamin by lambdamax * lambda_min_ratio.
A multiplicative factor for the minimal lambda in the
\code{lambda} sequence, where \code{lambdamin = lambda_min_ratio * lambdamax}.
A very small value will lead to the solution \code{ct = y}.
This argument has no effect if there is a user-defined \code{lambda} sequence.}

\item{maxiter}{Integer. Maximum number of iterations for the estimation
algorithm.}

\item{init}{a list of internal configuration parameters of class
\code{rt_admm_configuration}.}
}
\value{
An object with S3 class \code{smoothed_mult}. Among the list components:
\itemize{
\item \code{y} the observations
\item \code{x} a vector of positions at which the counts have been observed.
\item \code{convolved} the weighted sum of past \code{y}.
\item \code{ct} the estimated smoothed ratio This is a matrix with
each column corresponding to one value of \code{lambda}.
\item \code{lambda} the values of \code{lambda} actually used in the algorithm.
\item \code{korder} degree of the estimated piecewise polynomial curve.
\item \code{dof} degrees of freedom of the estimated trend filtering problem.
\item \code{niter} the required number of iterations for each value of \code{lambda}.
\item \code{convergence} if number of iterations for each value of \code{lambda} is less
than the maximum number of iterations for the estimation algorithm.
}
}
\description{
This function solves the smoothness penalized Gaussian
regression (trend filtering) of the form:
}
\details{
\eqn{\hat{\theta} = argmin_{\theta} (\frac{1}{n} \sum_{i=1}^n (y_i
#'   - \theta_i w_i)^2 + \lambda||D^{(k+1)}\theta||_1, }

where \eqn{y_i} are the observations at day
\eqn{i}, \eqn{w_i} are the weighted past observations at day \eqn{i},
convolved with a delay distribution (a gamma density by default),
\eqn{\lambda} is a tuning parameter, larger values resulting in smoother
estimates, and \eqn{D^{(k+1)}} is the \eqn{(k+1)}-th order
difference matrix.
}
\examples{
y <- c(1, rnorm(100, dnorm(1:100, 50, 15) * 500 + 1))
out <- estimate_ct(y)
plot(out)

out0 <- estimate_ct(y, korder = 1L, nsol = 10)
plot(out0)
}
